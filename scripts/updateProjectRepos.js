const fs = require('fs/promises');
const path = require('path');

const PROJECTS_PATH = path.join(process.cwd(), 'data', 'projects.ts');
const GENERATED_PATH = path.join(process.cwd(), 'data', 'projects.generated.ts');
const MAX_GITHUB_PAGES = 10;
const ENV_FILES = ['.env.local', '.env'];

const loadProjectsSource = async () => fs.readFile(PROJECTS_PATH, 'utf8');

const loadEnvFile = async (filePath) => {
    try {
        const raw = await fs.readFile(filePath, 'utf8');
        raw.split(/\r?\n/).forEach((line) => {
            const trimmed = line.trim();
            if (!trimmed || trimmed.startsWith('#')) return;
            const separatorIndex = trimmed.indexOf('=');
            if (separatorIndex === -1) return;
            const key = trimmed.slice(0, separatorIndex).trim();
            if (!key || process.env[key]) return;
            let value = trimmed.slice(separatorIndex + 1).trim();
            if (
                (value.startsWith('"') && value.endsWith('"')) ||
                (value.startsWith("'") && value.endsWith("'"))
            ) {
                value = value.slice(1, -1);
            }
            process.env[key] = value;
        });
    } catch {
        // ignore missing env files
    }
};

const loadEnv = async () => {
    for (const fileName of ENV_FILES) {
        const filePath = path.join(process.cwd(), fileName);
        try {
            await fs.access(filePath);
            await loadEnvFile(filePath);
        } catch {
            // ignore missing env files
        }
    }
};

const extractGithubUsername = (source) => {
    const match = source.match(/GITHUB_USERNAME\s*=\s*'([^']+)'/);
    return match ? match[1] : null;
};

const extractRepos = (source, defaultOwner) => {
    const repos = new Set();
    const regex = /repo:\s*'([^']+)'/g;
    let match;
    while ((match = regex.exec(source)) !== null) {
        const repo = match[1];
        if (!repo) continue;
        if (repo.includes('/')) {
            repos.add(repo.toLowerCase());
        } else if (defaultOwner) {
            repos.add(`${defaultOwner}/${repo}`.toLowerCase());
        }
    }
    return repos;
};

const buildGithubHeaders = () => {
    const headers = {
        Accept: 'application/vnd.github+json',
    };
    if (process.env.GITHUB_TOKEN) {
        headers.Authorization = `Bearer ${process.env.GITHUB_TOKEN}`;
    }
    return headers;
};

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

const fetchGithubRepos = async (owner) => {
    if (!owner) return [];
    const repos = new Set();
    const headers = buildGithubHeaders();
    const perPage = 100;
    for (let page = 1; page <= MAX_GITHUB_PAGES; page += 1) {
        const url = new URL(`https://api.github.com/users/${owner}/repos`);
        url.searchParams.set('per_page', String(perPage));
        url.searchParams.set('page', String(page));
        url.searchParams.set('type', 'owner');
        const response = await fetch(url.toString(), {headers});
        if (!response.ok) {
            break;
        }
        const payload = await response.json();
        if (!Array.isArray(payload) || payload.length === 0) {
            break;
        }
        payload.forEach((repo) => {
            if (repo?.fork) return;
            const fullName =
                repo?.full_name || (repo?.name ? `${owner}/${repo.name}` : null);
            if (fullName) {
                repos.add(fullName);
            }
        });
        if (payload.length < perPage) {
            break;
        }
        await sleep(120);
    }
    return Array.from(repos.values());
};

const buildRepoEntry = (repo) =>
    [
        '    {',
        `        repo: '${repo}',`,
        '    },',
    ].join('\n');

const updateProjects = async () => {
    await loadEnv();
    const source = await loadProjectsSource();
    const owner = extractGithubUsername(source) || process.env.GITHUB_USERNAME;
    if (!owner) {
        throw new Error('Missing GITHUB_USERNAME.');
    }
    const existing = extractRepos(source, owner);
    const repos = await fetchGithubRepos(owner);
    const missing = repos
        .filter((fullName) => !existing.has(fullName.toLowerCase()))
        .map((fullName) => {
            const [repoOwner, repoName] = fullName.split('/');
            if (repoOwner?.toLowerCase() === owner.toLowerCase()) {
                return repoName;
            }
            return fullName;
        })
        .filter(Boolean)
        .sort((a, b) => a.localeCompare(b));

    const header = [
        '// This file is generated by scripts/updateProjectRepos.js.',
        '// Do not edit by hand.',
        '',
        'export const PROJECTS_GENERATED = [',
    ].join('\n');
    const body = missing.map(buildRepoEntry).join('\n');
    const footer = [
        '];',
        '',
    ].join('\n');
    const updatedSource = `${header}${body ? `\n${body}\n` : '\n'}${footer}`;
    await fs.writeFile(GENERATED_PATH, updatedSource, 'utf8');
    if (missing.length === 0) {
        console.log('No new repositories found. Generated file cleared.');
        return;
    }
    console.log(`Generated ${missing.length} repositories in data/projects.generated.ts.`);
};

if (require.main === module) {
    updateProjects().catch((error) => {
        console.error(error);
        process.exitCode = 1;
    });
}

module.exports = {updateProjects};
